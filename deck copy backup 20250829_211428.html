<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>OracleFlow – Live Deck · Fan / Flip / Discard</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0" />

<style>
:root{
  --brand-blue:#277bfa; --brand-green:#1e9b6e;
  --brand-orange:#ff9e40; --brand-purple:#7748e0;
  --card-aspect:13/20;  --stagger-step:45ms; --stagger-cap:8;
  --fan-ms: .95s;        /* card transition duration (slightly faster) */
  --fan-ms-collapse: 1.10s;  /* stack a touch faster */
  --fan-ms-expand:   1.35s;  /* fan-out a touch slower */
  --riffle-ms: 360ms;     /* shuffle wiggle duration (was .30s/.33s) */
  --fan-ease: cubic-bezier(.25,.8,.35,1);  /* easing curve */
  --fan-ease-collapse: cubic-bezier(.22,.61,.36,1);  /* easeOutCubic-ish */
  --fan-ease-expand:   cubic-bezier(.16,.84,.44,1);  /* easeOutQuint-ish */
}

/* ---- base / layout ------------------------------------------------ */
* { box-sizing:border-box }
body{
  margin:0; min-height:100vh; background:#ecf3fd;
  display:flex; flex-direction:column; align-items:center;
  font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  padding-bottom: 120px; /* Add padding to prevent fanned cards from covering buttons */
}
.config-bar,.controls{
  margin:14px 0 0; display:flex; flex-wrap:wrap;
  align-items:center; justify-content:center; gap:.8em;
  font-size:1.05rem;
}
.config-bar label,.controls label{font-weight:500;color:#224}
select{
  padding:4px 10px; min-width:56px; font-size:1rem;
  border:1.5px solid #b9c7e0; border-radius:7px; background:#f7faff;
  transition:border-color .18s;
}
select:focus{ outline:none; border-color:var(--brand-blue) }
button{
  padding:7px 22px; font-size:1rem; font-weight:500; color:#fff;
  border:0; border-radius:8px; cursor:pointer;
  box-shadow:0 2px 10px 0 #bed3fa22; transition:background .2s, opacity .2s;
}
#collapseBtn{background:var(--brand-blue)}
#shuffleBtn {background:var(--brand-green)}
#resetBtn  {background:var(--brand-orange)}
#foutFlyBtn{background:#e74c3c}
button:disabled{background:#b8b9c8; cursor:not-allowed; opacity:.6}
.deck-label{
  margin:18px 0 10px; font:700 2.1rem/1.1 system-ui,sans-serif; color:#1e355d; text-align:center;
}

/* ---- deck / pile columns ----------------------------------------- */
.deck-wrapper{
  display: flex;
  align-items: flex-start;
  justify-content: center;
  gap: 48px;
  width: 100%;
  max-width: none;
  padding-inline: 0;
  min-height: 280px;
  padding-top: clamp(12px, 5vh, 60px);
  position: relative;
  transition: gap var(--fan-ms-expand) var(--fan-ease-expand);
}

.fan-wrapper{
  flex: 0 1 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  min-width: 0;
  /* was: height: 280px; */
  height: auto;                 /* let content define height */
  min-height: 280px;            /* floor for small sizes */
  justify-content: flex-end;
  padding-bottom: 20px;
}

.discard-area{
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  user-select: none;
  margin-top: 18px;
  opacity: 0;
  transform: translateX(20px);
  transition: opacity 0.35s ease, transform 0.35s ease;
  pointer-events: none;
  position: absolute;
  left: 50%;
  top: 0;
  z-index: 10;
  width: 130px;
}

.deck-info,.discard-info{
  margin-top: 24px;
  font: 600 1.1rem system-ui,sans-serif;
  color: #1e355d;
  text-align: center;
  height: 20px; /* Fixed height for consistent alignment */
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ---- fan tableau -------------------------------------------------- */
.fan-tableau{
  width: 99vw;
  max-width: 900px;
  margin-top: 0;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  border: 2px dashed transparent;
  border-radius: 12px;
  transition: border-color .18s;
  overflow: visible;
  content-visibility: visible;
  contain: none;
}
.fan-tableau.deck-hover{ border-color:var(--brand-blue) }

.fan-row{
  position: relative;
  width: 100%;
  height: calc(var(--cw) / var(--card-aspect));  /* exact card height */
  max-height: none;
  min-height: 0;
  margin-top: 0;                                   /* JS sets overlap */
  pointer-events: none;
  content-visibility: visible;
}
.fan-row:first-child{ margin-top: 0 }



/* ---- cards -------------------------------------------------------- */
.fan-card{
  --tx:0; --ty:0; --rot:0deg; --stackX:0; --stackY:0; --stackR:0deg; --row:0;
  position: absolute;
  top: auto;
  bottom: 0;
  left: var(--left, 0);
  width: 130px; /* Fixed width to match collapsed state */
  aspect-ratio: var(--card-aspect);
  min-width: 55px;
  max-width: 130px;
  border-radius: 16px;
  overflow: hidden;
  border: none;
  cursor: pointer;
  user-select: none;
  pointer-events: auto;
  background: transparent;
  transition:
    left var(--fan-ms) var(--fan-ease),
    transform var(--fan-ms) var(--fan-ease),
    box-shadow .18s, filter .18s;
  /* like the old build: stagger by row only */
  transition-delay:
    calc(min(var(--row), var(--stagger-cap)) * var(--stagger-step));
  transform: translate3d(var(--tx),var(--ty),0) rotate(var(--rot));
  /* revert to default (center) for old feel */
  transform-origin: 50% 50%;
  box-shadow: 0 2px 8px 1px rgba(60,70,120,.08);
  will-change: transform,left;
  appearance: none;
  -webkit-appearance: none;
  padding: 0;
  -webkit-tap-highlight-color: transparent;
}
  .fan-card:focus { outline: none; }

  /* PHASE A — collapsing while deck is still wide:
     keep each card's fan 'left', animate only the transform to the stack. */
  .fan-tableau.is-collapsed .fan-card{
    /* left remains: var(--left) from .fan-card */
    transform: translate3d(var(--stackX), var(--stackY), 0) rotate(var(--stackR));
    transition:
      transform var(--fan-ms) var(--fan-ease),
      box-shadow .18s, filter .18s;   /* 'left' never animates while collapsed */
  }

  /* PHASE B — once the narrow column is active:
     each card moves to its calculated collapse position. */
  .deck-wrapper.collapsed-mode .fan-tableau.is-collapsed .fan-card,
  .deck-wrapper.collapsed-mode .fan-card{
    left: var(--final-collapsed-left, 0px) !important;
    transform:
      translate3d(var(--stackX), var(--stackY), 0)
      rotate(var(--stackR)) !important;
  }

  .fan-card img{ width:100%; height:100%; object-fit:contain; display:block }
.fan-card .num{position:absolute;top:4px;left:6px;padding:0 4px;border-radius:4px;
               background:#1e355de6;color:#fff;font-size:.70rem;font-weight:600;z-index:10}
.fan-card.is-lifted{
  filter:brightness(1.07) saturate(1.13);
  box-shadow:0 16px 40px 10px rgba(39,123,250,.17);
  transform:translate3d(var(--tx),calc(var(--ty) - 10px),0) rotate(var(--rot)) scale(1.04);
}
.fan-card:focus-visible{ outline:3px solid var(--brand-blue); outline-offset:2px }

/* Visual feedback when draw limit is reached */
.fan-card.draw-limit-reached{
  cursor: not-allowed;
}

/* single composited effect on the whole deck */
.fan-tableau.limit-reached{
  position: relative;
  filter: grayscale(.12) brightness(.95);   /* subtle dim without stacking blur */
  cursor: not-allowed;
}

/* optional soft veil instead of filter (comment the filter above if you prefer this) */
.fan-tableau.limit-reached::before{
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 12px;
  background: rgba(255,255,255,.35);
  pointer-events: none;                    /* clicks still reach your handler */
}

/* Brief feedback when trying to exceed draw limit */
.fan-card.limit-feedback{
  box-shadow: 0 0 0 3px var(--brand-orange) !important;
}





/* shuffle riffle */
@keyframes riffle{
  0%  { transform:translate3d(var(--stackX),var(--stackY),0) rotate(calc(var(--stackR) - 3deg)); }
  50% { transform:translate3d(calc(var(--stackX) + 6px),calc(var(--stackY) + 4px),0) rotate(calc(var(--stackR) + 3deg)); }
  100%{ transform:translate3d(var(--stackX),var(--stackY),0) rotate(var(--stackR)); }
}

/* A riffle that pulses in place from the collapsed center */
@keyframes riffleInPlace {
  0%   { transform: translate3d(var(--stackX), var(--stackY), 0)
                   rotate(calc(var(--stackR) - 2deg)) scale(1); }
  35%  { transform: translate3d(calc(var(--stackX) + (var(--i) - var(--mid)) * 0.6px),
                            calc(var(--stackY) - 6px), 0)
                   rotate(calc(var(--stackR) + 2deg)) scale(1.05); }
  65%  { transform: translate3d(var(--stackX), calc(var(--stackY) + 2px), 0)
                   rotate(calc(var(--stackR) - 1deg)) scale(0.985); }
  100% { transform: translate3d(var(--stackX), var(--stackY), 0)
                   rotate(var(--stackR)) scale(1); }
}

  /* When the deck is collapsed or shuffling, don't animate `left` — only `transform`. */
  .fan-tableau.is-collapsed .fan-card,
  .fan-tableau.is-collapsed.is-shuffling .fan-card {
    transition:
      transform var(--fan-ms) var(--fan-ease),
      box-shadow .18s,
      filter .18s;              /* left transition removed */
  }

  /* Use the in-place riffle only when collapsed */
  .fan-tableau.is-collapsed.is-shuffling .fan-card {
    animation: riffleInPlace var(--riffle-ms) cubic-bezier(.22,1,.36,1);
  }

  /* Keep the old riffle for the fanned view */
  .fan-tableau:not(.is-collapsed).is-shuffling .fan-card {
    animation: riffle var(--riffle-ms) ease-in-out;
  }

  /* When fanning out after a shuffle, ensure cards start from center */
  
  /* Set width for collapsed cards using the --cw variable */
  .fan-tableau.is-collapsed .fan-card {
    width: var(--cw);
  }
  .fan-tableau:not(.is-collapsed) .fan-card {
    transition:
      left var(--fan-ms) var(--fan-ease),
      transform var(--fan-ms) var(--fan-ease),
      box-shadow .18s, filter .18s;
  }

/* === deck shake animation === */
@keyframes deckShake {
  0%{ transform:translateX(0); }
  20%{ transform:translateX(-2px); }
  40%{ transform:translateX(2px); }
  60%{ transform:translateX(-2px); }
  80%{ transform:translateX(2px); }
  100%{ transform:translateX(0); }
}

.deck-shake {
  animation: deckShake 0.5s ease infinite;
}

/* === shuffle message === */
.shuffle-message {
  width:100%; 
  text-align:center; 
  font-weight:bold; 
  background:transparent; 
  color:transparent; 
  margin-bottom:10px; 
  min-height:40px; 
  display:block; 
  padding:10px; 
  box-sizing:border-box;
  margin-bottom: 0;
  transition: background-color 0.3s ease, color 0.3s ease;
}
.shuffle-message.active {
  background:#c9f1ff; 
  color:#333;
}
#shuffleText { display:inline-block; }

/* ---- discard pile ------------------------------------------------- */
.discard-area{
  display:flex; flex-direction:column; align-items:center; gap:6px;
  cursor:pointer; user-select:none; margin-top:18px;
  opacity: 0;
  transform: translateX(20px);
  transition: opacity 0.15s ease, transform 0.15s ease;
  pointer-events: none;
  position: absolute;
  left: 50%;
  top: 0;
  z-index: 10;
  width: 130px; /* Match the collapsed deck width */
}



/* Show discard pile only when column is in collapsed mode */

.discard-stack{
  width:130px; aspect-ratio:var(--card-aspect); border-radius:16px;
  background:#d8d8d8 center/cover; box-shadow:0 6px 16px rgba(0,0,0,.25);
  opacity:.25; transition:transform .25s, opacity .25s, outline-offset .2s;
}
.discard-area.has-cards .discard-stack{ opacity:1 }
.discard-area.hover .discard-stack{ outline:3px dashed var(--brand-blue); outline-offset:4px }
/* Removed hover transform to prevent movement */
.discard-badge, .deck-badge{
  padding:2px 10px; border-radius:14px; background:#1e355d; color:#fff;
  font-weight:600; font-size:.9rem; min-width:36px; text-align:center;
  transform:scale(0); transition:transform .25s;
}
.discard-badge{ transform:scale(1) }
.deck-badge{ transform:scale(1) }

/* ---- reveal strip ------------------------------------------------- */
.selected-area{
  margin:32px auto 40px; width:100%; max-width:1100px; min-height:120px;
  display:flex; flex-wrap:wrap; justify-content:center; gap:16px;
  border:2px dashed transparent; border-radius:12px; transition:border-color .18s;
}
.selected-area.drop-hover{ border-color:var(--brand-blue) }
.selected-card{ 
  display:flex; flex-direction:column; align-items:center;
  cursor: pointer;
  transition: transform 0.2s ease;
}
.selected-card:hover {
  transform: scale(1.05);
}
.label{ margin-top:6px; font-weight:600; color:#1e355d }

/* ---- Modal Styles ------------------------------------------------- */
.modal { 
  display:none; 
  position:fixed; 
  z-index:9999; 
  left:0; 
  top:0; 
  width:100%; 
  height:100%; 
  overflow:auto; 
  background-color:rgba(0,0,0,0.8); 
}
.modal-content {
  margin:auto; 
  display:block; 
  max-width:90%; 
  max-height:90%; 
  box-shadow:0 2px 10px rgba(0,0,0,0.5); 
  border-radius:8px; 
  transition:transform 0.6s;
}
.modalClose {
  position:absolute; 
  top:10px; 
  right:10px; 
  color:#fff; 
  font-size:35px; 
  font-weight:bold; 
  cursor:pointer; 
  z-index:10001;
}
.modal-caption {
  color:#ccc; 
  text-align:center; 
  margin-top:10px; 
  font-size:18px; 
  font-weight:500;
}
.modal-nav {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}
.modal-nav-btn {
  background-color: #228b22; 
  color: #fff; 
  border: none; 
  border-radius: 5px; 
  font-size: 16px; 
  padding: 8px 16px; 
  cursor: pointer; 
  opacity: 1;
}
.modal-nav-btn:hover { opacity:0.9; }
.modal-nav-btn:disabled { 
  cursor:not-allowed; 
  background-color:#aaa; 
  opacity:0.7; 
}

/* The wrapper in "no-details" state => single column, centered */
.modal-content-wrapper {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  max-height: 80vh;
  overflow: auto;
  transition: all 0.4s ease;
}

/* The <img> can be 350px wide when details are hidden */
.modal-image img {
  max-width: 350px;
  height: auto;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.5);
}
.modal-image-large img {
  max-width: 500px;
  max-height: calc(100vh - 150px);
  object-fit: contain;
}

/* WHEN DETAILS ARE SHOWN:
   We toggle a .show-details class on the wrapper => become side-by-side */
.modal-content-wrapper.show-details {
  flex-direction: row;
  align-items: flex-start;
  gap: 20px;
}

/* If you want the card smaller or the same 350px, that's your call:
   In a side-by-side layout, keep or reduce its max-width. */
.modal-content-wrapper.show-details .modal-image img {
  max-width: 350px;
}

/* The details container can fill remaining space if you want: */
.modal-details {
  flex: 1;
  max-height: 80vh;
  overflow-y: auto;
  background: #fff;
  border-radius: 8px;
  padding: 10px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

/* On narrower screens, you can revert to stacking with a media query: */
@media (max-width: 768px) {
  /* Use column layout when showing details, so card + details stack */
  .modal-content-wrapper.show-details {
    flex-direction: column;
    align-items: center;
  }

  /* If you want the nav above the details, do: */
  .modal-nav {
    order: 2;
  }
  .modal-details {
    order: 3; 
    overflow-y: auto;
    width: 100%;
    margin-top: 1rem; 
  }

  /* BIG card when details are NOT shown */
  .modal-content-wrapper:not(.show-details) .modal-image img {
    max-width: 90vw;
    max-height: 80vh;
    height: auto;
  }

  /* SMALLER card when details are shown */
  .modal-content-wrapper.show-details .modal-image img {
    max-width: 40vw;
    max-height: 40vh;
    height: auto;
  }
}

/* ---- flip faces --------------------------------------------------- */
.card-wrapper{
  width:130px; aspect-ratio:var(--card-aspect); border-radius:16px;
  perspective:1200px; overflow:hidden;
}
.card-inner{
  position:relative; width:100%; height:100%;
  transform-style:preserve-3d;
  transition:transform 1s cubic-bezier(.26,.6,.23,1);
  will-change:transform;
}
.card-wrapper.flipped .card-inner{ transform:rotateY(180deg) }
.card-face{
  position:absolute; inset:0; backface-visibility:hidden; border-radius:inherit;
}
.card-front{ transform:rotateY(180deg) }
.card-back { transform:none }
  .card-face img{ width:100%; height:100%; object-fit:contain; display:block }

  /* === Collapsed mode: shared width + safe height ==================== */
  .deck-wrapper.collapsed-mode { --cw: 130px; } /* JS overwrites this */

  .deck-wrapper.collapsed-mode .fan-wrapper,
  .deck-wrapper.collapsed-mode .discard-area{
    /* Use min-height so larger cards don't push up into the buttons */
    min-height: calc(var(--cw) / var(--card-aspect) + 40px); /* card + bottom padding + badges */
    height: auto;
    width: var(--cw);
    justify-content: flex-end;
    padding-bottom: 20px;
    margin-top: 0; /* ensure Discard column doesn't sit higher than Deck */
  }

  /* COLLAPSED MODE: keep the deck's internal width = column width */
  .deck-wrapper.collapsed-mode { gap: 16px; } /* give breathing room */
  .deck-wrapper.collapsed-mode .fan-tableau,
  .deck-wrapper.collapsed-mode .fan-row {
    width: var(--cw);
    /* Remove auto centering - let fan center positioning handle it */
    margin-inline: 0;
  }

  .deck-wrapper.collapsed-mode .fan-row {
    height: calc(var(--cw) / var(--card-aspect)); /* exact card height */
  }

  /* Discard stack fills its column in collapsed mode */
  .deck-wrapper.collapsed-mode .discard-stack{ width: 100%; }

  /* Show discard pile when deck is collapsed */
  .deck-wrapper.collapsed-mode .discard-area {
    opacity: 1;
    transform: none;
    pointer-events: auto;
    position: static;
    left: auto;
  }

  /* Hide discard pile during shuffle animation when starting from fanned mode */
  .deck-wrapper.collapsed-mode.shuffling .discard-area {
    opacity: 0 !important;
    pointer-events: none !important;
  }





/* === Badge and Label Styling === */

/* Ensure consistent badge positioning for both collapsed and fanned states */
.deck-badge,
.discard-badge {
  order: 1; /* Badges come first */
  margin-bottom: 8px; /* Consistent gap between badge and label */
  height: 24px; /* Fixed height for perfect alignment */
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 24px; /* Ensure minimum height even when hidden */
}

.deck-info,
.discard-info {
  order: 2; /* Labels come second */
  margin-top: 0; /* Remove any default margin */
  height: 20px; /* Fixed height for consistent spacing */
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Ensure consistent badge positioning for both collapsed and fanned states */
.deck-badge,
.discard-badge {
  order: 1; /* Badges come first */
  margin-bottom: 8px; /* Consistent gap between badge and label */
  height: 24px; /* Fixed height for perfect alignment */
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 24px; /* Ensure minimum height even when hidden */
}

/* Ensure perfect text alignment for deck and discard labels */
.deck-info,
.discard-info {
  order: 2; /* Labels come second */
  text-align: center !important;
  font-weight: 600;
  font-size: 1.1rem;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  color: #1e355d;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0;
  padding: 0;
}

/* Show discard badge when there are cards */
.discard-area.has-cards .discard-badge {
  transform: scale(1);
}

/* Let --cw drive width; don't cap at 130px globally */
.fan-card,
.discard-stack { max-width: none; }

/* Optional: small-phone caps only when fan is visible ( NOT collapsed ) */
@media (max-width: 650px){
  .fan-tableau:not(.is-collapsed) .fan-card,
  .deck-wrapper:not(.collapsed-mode) .discard-stack { max-width: 80px; }
}
@media (max-width: 480px){
  .fan-tableau:not(.is-collapsed) .fan-card,
  .deck-wrapper:not(.collapsed-mode) .discard-stack { max-width: 60px; }
}

/* Discard stack styling */
.discard-stack{
  width: var(--cw);
  aspect-ratio: var(--card-aspect);
  border-radius: 16px;
  background: #d8d8d8 center/cover;
  box-shadow: 0 6px 16px rgba(0,0,0,.25);
  opacity: .25;
  transition: transform .25s, opacity .25s, outline-offset .2s;
  min-width: 55px;
  max-width: none;    /* no clamp */
}
.discard-area.has-cards .discard-stack{ opacity: 1 }




/* ---- motion preferences ------------------------------------------ */
@media (prefers-reduced-motion: reduce){
  .fan-card,
  .card-inner{ transition:none !important; animation:none !important }
}

/* ---- loading indicator ------------------------------------------- */
.loading-indicator {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255, 255, 255, 0.95);
  padding: 20px 30px;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  z-index: 10000;
  display: flex;
  align-items: center;
  gap: 12px;
  font-weight: 500;
  color: #1e355d;
  opacity: 0;
  transition: opacity 0.3s ease;
}

/* ---- deck loading spinner ------------------------------------------- */
.deck-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-top: 24px;
  opacity: 1;
  transition: opacity 0.3s ease;
}

/* When the deck finishes loading, remove the spinner from layout */
.deck-loading.hidden {
  opacity: 0;
  pointer-events: none;
  height: 0;
  margin: 0;
  overflow: hidden;
}

/* During a collapse/fan toggle, neutralize per-card micro‑stagger */
.fan-tableau.is-toggling .fan-card{
  transition-property: transform, box-shadow, filter;
  transition-delay: calc(min(var(--row), var(--stagger-cap)) * var(--stagger-step));
}

/* keep the transition ultra-clean on low/medium GPUs */
.fan-tableau.is-toggling { contain: paint; }  /* isolates repaints inside the tableau */

.fan-tableau.is-toggling .fan-card{
  /* turn off costly effects for ~1s, then they come back automatically */
  box-shadow: none !important;
  filter: none !important;
  will-change: transform;
}

/* Freeze transitions for one frame while we swap layout/geometry */
.fan-tableau.is-freeze .fan-card { transition: none !important; }

/* When collapsing: use collapse duration & curve */
.fan-tableau.is-collapsing .fan-card{
  transition-duration: var(--fan-ms-collapse);
  transition-timing-function: var(--fan-ease-collapse);
}

/* When expanding: use expand duration & curve */
.fan-tableau.is-expanding .fan-card{
  transition-duration: var(--fan-ms-expand);
  transition-timing-function: var(--fan-ease-expand);
}

/* While collapsed, render cards at a fixed collapsed width. 
   JS sets --cw-collapsed when entering collapsed, and removes it when fanning out. */




.deck-spinner {
  width: 24px;
  height: 24px;
  border: 2px solid #e0e7ff;
  border-top: 2px solid var(--brand-blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.deck-loading-text {
  font-size: 0.9rem;
  font-weight: 500;
  color: #1e355d;
  text-align: center;
}

.loading-indicator.visible {
  opacity: 1;
}

.loading-spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #e0e7ff;
  border-top: 2px solid var(--brand-blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* ---- small discard badge ----------------------------------------- */
.discard-badge-small {
  position: absolute;
  top: -8px;
  right: -8px;
  background: var(--brand-orange);
  color: white;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.8); }
  to { opacity: 1; transform: scale(1); }
}

/* Position the badge relative to the collapse button */
#collapseBtn {
  position: relative;
}

/* === OVERRIDES: let --cw drive width; don't cap at 130px =========== */

/* Let the computed --cw be the source of truth everywhere */
.fan-card,
.discard-stack {
  max-width: none;    /* was 130px – this is what blocked Large / XL */
}

/* On small screens, keep narrow cards only when FAN is visible.
   In COLLAPSED mode, allow cards to fill the slot so Deck & Discard align. */
@media (max-width: 650px){
  .fan-tableau:not(.is-collapsed) .fan-card,
  .deck-wrapper:not(.collapsed-mode) .discard-stack {
    max-width: 80px;
  }
}

@media (max-width: 480px){
  .fan-tableau:not(.is-collapsed) .fan-card,
  .deck-wrapper:not(.collapsed-mode) .discard-stack {
    max-width: 60px;
  }
}

/* ---- mobile tweaks ----------------------------------------------- */
@media(max-width:650px){
  .fan-card, .discard-stack{ min-width:35px; }
  .card-wrapper{ width:80px }
  
  /* Neutralize mobile rules when collapsed */
  .deck-wrapper.collapsed-mode .fan-row{
    min-height: 0;
    max-height: none;
    margin-top: 0;
    height: calc(var(--cw) / var(--card-aspect));
  }
  
  /* Stop hardcoding discard widths on mobile; let --cw rule everything */
  .discard-stack{ width: auto; } /* non-collapsed can use inline width from JS */
}
@media(max-width:480px){
  .fan-card, .discard-stack{ min-width:28px; }
  .card-wrapper{ width:60px }
  
  /* Stop hardcoding discard widths on mobile; let --cw rule everything */
  .discard-stack{ width: auto; }
}
</style>
</head>
<body>
  <!-- UI -->
  <div class="config-bar" role="group" aria-label="Deck options">
    <label><input type="checkbox" id="enableDiscard" checked /> Discard Pile</label>
    <label for="collapseMode">Deck View:</label>
    <select id="collapseMode" aria-label="Deck view mode">
      <option value="both" selected>Both (Toggle)</option>
      <option value="collapsed">Collapsed Deck Only</option>
      <option value="foutfly">FOutFly Enabled</option>
    </select>

    <label for="cardSize">Card Size:</label>
<select id="cardSize" aria-label="Card size">
  <option value="0.85">Small</option>
  <option value="1" selected>Medium</option>
  <option value="1.2">Large</option>
  <option value="1.4">XL</option>
</select>
    <label for="drawLimit">Draw Limit:</label>
<select id="drawLimit" aria-label="Draw limit">
  <option value="0">No Limit</option>
  <option value="1">1 Card</option>
  <option value="3">3 Cards</option>
  <option value="5">5 Cards</option>
  <option value="10">10 Cards</option>
  <option value="20">20 Cards</option>
</select>

  </div>

  <h1 class="deck-label">OracleFlow</h1>

  <div class="controls" role="group" aria-label="Deck controls">
    <button id="collapseBtn" aria-pressed="false" title="C">Collapse</button>
    <button id="shuffleBtn"  title="S">Shuffle</button>
    <button id="resetBtn"    title="R">Reset</button>
    <button id="foutFlyBtn" title="FO">FOutFly</button>
    <div class="discard-badge-small" id="discardBadgeSmall" style="display: none;">
      <span id="discardCountSmall">0</span>
    </div>
  </div>

  <div id="shuffleMessage" class="shuffle-message">
    <span id="shuffleText"></span>
  </div>

  <div class="deck-wrapper">
    <div class="fan-wrapper">
      <div class="fan-tableau" id="fan-tableau" role="list" aria-label="Deck"></div>
      <div class="deck-loading" id="deckLoading">
        <div class="deck-spinner"></div>
        <div class="deck-loading-text">Loading deck...</div>
      </div>
      <div class="deck-badge" id="deckCount" aria-live="polite" style="display: none;">0</div>
      <div class="deck-info" id="deckInfo" style="display:none;">Deck</div>
    </div>

    <div class="discard-area" id="discardArea" aria-label="Discard pile" tabindex="0">
      <div class="discard-stack" id="discardStack"></div>
      <div class="discard-badge" id="discardCount" aria-live="polite">0</div>
      <div class="discard-info">Discard</div>
    </div>
  </div>

  <div class="selected-area" id="selectedArea" aria-label="Revealed cards"></div>
  


  <!-- ======================
   Modal for Full Screen Card View
====================== -->
  <div id="cardImageModal" class="modal">
    <span class="modalClose" id="modalClose">&times;</span>
    
    <!-- The new content wrapper that can be in "single-card" or "card+details" layout -->
    <div class="modal-content-wrapper" id="modalContentWrapper">
      <!-- Left side: the big card image -->
      <div class="modal-image">
        <img id="modalImg" />
      </div>

      <!-- Right side: the detail container, hidden by default -->
      <div class="modal-details" id="modalDetailsSide" style="display:none;">
        <!-- We'll populate details here dynamically -->
      </div>
    </div>

    <!-- Caption below, if you want -->
    <div id="modalCaption" class="modal-caption"></div>

    <!-- Bottom nav with Prev/Next -->
    <div class="modal-nav" id="modalNav">
      <button id="modalPrev" class="modal-nav-btn">Previous</button>
      <button id="modalNext" class="modal-nav-btn">Next</button>
      <button id="modalToggleDetails" class="modal-nav-btn" style="display:none;">Show Details</button>
      <button id="modalOrientationBtn" class="modal-nav-btn" style="display:none;">View Upright</button>
    </div>
  </div>

  <!-- Loading indicator -->
  <div class="loading-indicator" id="loadingIndicator">
    <div class="loading-spinner"></div>
    <span>Loading cards...</span>
  </div>

  <!-- Deck definition -->
  <script id="deck-loader"
          data-deck-key="decks/ww2_26bc8e22-f7f3-4b56-b64f-95c8230d32b7.json"
          data-public-id="d1227ffb-b983-486e-8cb2-4df406b38109"></script>

  <script type="module">
  /* ========================== CONSTANTS & DOM ========================== */
  const $ = id => document.getElementById(id);
  const fan = $('fan-tableau'), selected = $('selectedArea'),
        pileArea = $('discardArea'), pileStack = $('discardStack');
  const deckCount = $('deckCount'), discardCount = $('discardCount');
  const deckLoading = $('deckLoading'), deckInfo = $('deckInfo');
  const deckWrap = document.querySelector('.deck-wrapper');
  const collapseB = $('collapseBtn'), shuffleB = $('shuffleBtn'), resetB = $('resetBtn');
  const foutFlyB = $('foutFlyBtn');
  const enableDiscard = $('enableDiscard'), collapseMode = $('collapseMode');
  const loadingIndicator = $('loadingIndicator');
  
  // Shuffle message elements
  const shuffleMsg = $('shuffleMessage');
  const shuffleText = $('shuffleText');
  
  // Modal elements
  const modal = $('cardImageModal'), modalImg = $('modalImg'), modalCaption = $('modalCaption'),
        closeBtn = $('modalClose'), nextBtn = $('modalNext'), prevBtn = $('modalPrev'),
        modalNav = $('modalNav'), modalContentWrapper = $('modalContentWrapper'),
        detailsSide = $('modalDetailsSide'), toggleDetailsBtn = $('modalToggleDetails'),
        orientationBtn = $('modalOrientationBtn');
  
  let currentModalIndex = 0;
  let detailsVisible = false;
  
  // Collapsed mode helpers
  const collapsedCW = () => Math.round(130 * cardScale); // one source of truth
  
  function applyCollapsedSize(){
    const cw = collapsedCW();
    if (deckWrap) deckWrap.style.setProperty('--cw', `${cw}px`);
    // In collapsed mode, .discard-stack is width:100%; otherwise set explicit width.
    if (collapsed) {
      pileStack.style.removeProperty('width'); // let CSS (100%) take over
    } else {
      pileStack.style.width = `${collapsedCW()}px`; // keep discard responsive to slider
    }
  }  

  


  const API_DECK = "https://yrc76i5e6e.execute-api.us-east-2.amazonaws.com/api/cards";
  const API_URLS = "https://yrc76i5e6e.execute-api.us-east-2.amazonaws.com/api/card-urls";
  const PER_ROW  = 100, RIFFLE_MS = 560, FLIP_DELAY = 400;

  /* =============================== STATE ============================== */
  let deck = [], discard = [], revealed = [];
  let cardBackURL = "", PUBLIC_ID = "";
  let collapsed = false, allowDiscard = true, allowCollapse = true;
let cardScale = 1; // 0.85 (S), 1 (M), 1.2 (L), 1.4 (XL)
let drawLimit = 0; // 0 = no limit, otherwise max cards that can be drawn
let toggling = false;
let isShuffling = false; // Track if we're in shuffle animation
let foutFlyCards = new Map(); // Track cards that are fanned out: cardId -> {element, originalPosition}
let isFoutFlyMode = false; // Track if we're in fan out fly mode
  const CARD_ASPECT = (() => {
    const raw = getComputedStyle(document.documentElement)
                 .getPropertyValue('--card-aspect').trim();
    const n = parseFloat(raw);
    return Number.isFinite(n) && n > 0 ? n : (13/20);
  })();



  /* ======== UTIL: RAF throttle (for resize) ========================== */
  const rafThrottle = fn => {
    let ticking = false;
    return (...args) => {
      if (!ticking){
        requestAnimationFrame(() => { fn(...args); ticking = false; });
        ticking = true;
      }
    };
  };

  // utilities to read CSS variables
  const readMSVar = (name, fallback) => {
    const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    if (!raw) return fallback;
    if (raw.endsWith('ms')) return parseFloat(raw);
    if (raw.endsWith('s'))  return parseFloat(raw) * 1000;
    const n = parseFloat(raw);
    return Number.isFinite(n) ? n : fallback;
  };

  const FAN_MS    = () => readMSVar('--fan-ms', 1100);   // from CSS
  const FAN_MS_COLLAPSE = () => readMSVar('--fan-ms-collapse', FAN_MS());
  const FAN_MS_EXPAND   = () => readMSVar('--fan-ms-expand',   FAN_MS());
  const RIFFLE_MS_VAR = () => readMSVar('--riffle-ms', 560); // from CSS

  /* ====================== GEOMETRY / LAYOUT ========================== */
  const spanDeg = n => (n <= 10 ? 12 : n >= 30 ? 4 : 12 - 8 * (n - 10) / 20);
  const rowGeom = (cnt, cw, W) => {
    const s = spanDeg(cnt), min = -s/2, max = s/2;
    const spread = cnt === 1 ? 0 : (W - cw) / (cnt - 1);
    const vR = Math.max(cw * .09, 8);
    const c = ((cnt - 1) * spread) / 2;

    return Array.from({length: cnt}, (_, i) => ({
      left: i * spread,
      tx: 0,
      ty: -Math.sin((min + (max - min) * i / (cnt - 1)) * Math.PI / 180) * vR,
      rot: min + (max - min) * i / (cnt - 1),
      stackX: c - i * spread, stackY: 0, stackR: 0
    }));
  };
  const styleCard = (el, g, i, total, additionalOffset = 0) => {
    // let CSS control the `left` via a var so Phase‑B `left:50%` can win
    el.style.setProperty('--left', g.left + 'px');
    el.style.setProperty('--tx', g.tx + 'px');
    el.style.setProperty('--ty', g.ty + 'px');
    el.style.setProperty('--rot', g.rot + 'deg');
    const stackXValue = g.stackX + additionalOffset;
    el.style.setProperty('--stackX', stackXValue + 'px');
    el.style.setProperty('--stackY', g.stackY + 'px');
    el.style.setProperty('--stackR', g.stackR + 'deg');
    el.style.setProperty('--i', i || 0);
    el.style.setProperty('--mid', total ? (total - 1) / 2 : 0);
    el.style.setProperty('--i-del', i % 8);
    
    // Debug: log the stackX value being set
    if (additionalOffset !== 0) {
      console.log(`Card ${i}: setting --stackX to ${stackXValue}px (base: ${g.stackX}, offset: ${additionalOffset})`);
    }
  };


  const tidyRows = () => {
    const narrow   = fan.offsetWidth < 600;
    const overlap  = narrow ? 0.85 : 0.60; // same intent as your code
    const rows     = document.querySelectorAll('.fan-row');

    rows.forEach((r, i) => {
      if (i === 0){ r.style.marginTop = '0'; return; }
      const cw = parseFloat(r.dataset.cw) || 130;
      const h  = cw / CARD_ASPECT;
      r.style.marginTop = `-${(h * overlap).toFixed(2)}px`;
    });
  };
  const updateZ = () => {
    document.querySelectorAll('.fan-row').forEach((row,r)=>{
      [...row.children]
        .sort((a,b)=>a.offsetLeft - b.offsetLeft)
        .forEach((c,i)=>c.style.zIndex = r * PER_ROW + i);
    });
  };
  const updateCounts = () => {
    deckCount.textContent = deck.length;
    discardCount.textContent = discard.length;
    const has = discard.length > 0;
    pileArea.classList.toggle('has-cards', has);
    if (has) pileStack.setAttribute('draggable','true');
    else     pileStack.removeAttribute('draggable');
    
    // Update small discard badge
    const smallBadge = $('discardBadgeSmall');
    const smallCount = $('discardCountSmall');
    if (smallBadge && smallCount) {
      smallCount.textContent = discard.length;
      // Show badge only when fan is out and deck is loaded
      if (!collapsed) {
        smallBadge.style.display = 'flex';
      } else {
        smallBadge.style.display = 'none';
      }
    }

    // Update draw limit visual state
    updateDrawLimitState();
  };

  const updateDrawLimitState = () => {
    const limitReached = drawLimit > 0 && revealed.length >= drawLimit;

    // Visually lock/unlock the deck at the container level
    fan.classList.toggle('limit-reached', limitReached);

    // (Optional) keep the "not allowed" cursor on cards if you still want it
    document.querySelectorAll('.fan-card').forEach(card => {
      card.classList.toggle('draw-limit-reached', limitReached);
    });
  };

  const showDeckLoaded = () => {
    if (deckLoading){
      deckLoading.classList.add('hidden');
      // After the fade, take it out of layout completely
      const onEnd = () => {
        deckLoading.style.display = 'none';
        deckLoading.removeEventListener('transitionend', onEnd);
      };
      deckLoading.addEventListener('transitionend', onEnd);
    }

    if (deckCount) deckCount.style.display = 'flex';
    if (deckInfo)  deckInfo.style.display  = 'flex';

    updateCounts();
  };

  /* ========================= HTML BUILDERS =========================== */
  const flipHTML = c => `
    <div class="selected-card" role="group" aria-label="${c.name || 'Card'}" data-card-id="${c.id}">
      <div class="card-wrapper">
        <div class="card-inner">
          <div class="card-face card-front"><img alt="${c.name || 'front'}" src="${c.url}"></div>
          <div class="card-face card-back"><img alt="back" src="${cardBackURL}"></div>
        </div>
      </div>
      ${c.name ? `<div class="label">${c.name}</div>` : ''}
    </div>`;

  /* ========================= NETWORK HELPERS ========================= */
  async function fetchWithRetry(url, opt = {}, tries = 3, delay = 350){
    let last;
    for(let i=0;i<tries;i++){
      try{
        const res = await fetch(url, opt);
        if (!res.ok) {
          const errorText = await res.text().catch(() => 'No error details available');
          console.error(`HTTP ${res.status} error for ${url}:`, errorText);
          throw new Error(`HTTP ${res.status}: ${errorText}`);
        }
        return res;
      }catch(e){
        last = e;
        console.warn(`Attempt ${i+1}/${tries} failed for ${url}:`, e.message);
        if (i < tries - 1) {
          await new Promise(r=>setTimeout(r, delay * Math.pow(2,i)));
        }
      }
    }
    throw last;
  }

  /* ======== IMAGE LOADING (priority + viewport + idle) ============== */
  const imageCache = Object.create(null);
  let loadingQueue = [];
  let isLoading = false;

  async function getCardImageURL(key){
    if (imageCache[key]) return imageCache[key];
    const body = PUBLIC_ID ? {filenames:[key], public_id:PUBLIC_ID} : {filenames:[key]};
    console.log('Requesting card URL for:', key, 'with body:', body);
    const resp = await fetchWithRetry(API_URLS,{
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body)
    }).then(r=>r.json());
    console.log('Card URL response:', resp);
    const url = (resp.images || []).find(i=>i.key === key)?.url;
    if (url) imageCache[key] = url;
    return url;
  }

  async function ensureFront(card, {priority=false} = {}){
    if (card.url) return card.url;
    const url = await getCardImageURL(card.key);
    if (!url) return null;

    // Priority decode path—block flip until GPU-decoded
    if (priority){
      const im = new Image();
      im.src = url;
      try { if (im.decode) await im.decode(); } catch {}
    } else {
      // Background warm-up (no await)
      const im = new Image();
      im.loading = 'eager';
      im.src = url;
    }

    card.url = url;
    return url;
  }

  // Progressive loading queue
  async function processLoadingQueue() {
    if (isLoading || loadingQueue.length === 0) return;
    isLoading = true;
    
    while (loadingQueue.length > 0) {
      const { card, priority = false } = loadingQueue.shift();
      try {
        await ensureFront(card, { priority });
        // Don't update fan cards - they should stay as back images
        // Only flip when explicitly clicked
      } catch (error) {
        console.warn('Failed to load card:', card.key, error);
      }
    }
    
    isLoading = false;
  }

  function queueCardLoad(card, priority = false) {
    loadingQueue.push({ card, priority });
    processLoadingQueue();
  }

  // Viewport preloader - DISABLED to prevent automatic card flipping in fan
  // Cards will only load when explicitly clicked
  const io = null; // Disable intersection observer

  // Idle background warm-up (fallback-friendly, Safari-safe)
  const idleWarm = () => {
    const warm = async () => {
      // Don't preload any cards - only load when clicked
      // This keeps the fan fast and responsive
      console.log('Fan ready - cards will load on demand when clicked');
    };
    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(warm, { timeout: 2000 });
    } else {
      setTimeout(warm, 300);
    }
  };

  // Update only visible cards in the fan - DISABLED to prevent automatic flipping
  function updateVisibleCards() {
    // Do nothing - cards should stay as back images in the fan
    // Only flip when explicitly clicked and revealed
  }

  // Fast fan building - show all cards immediately with back images
  function buildFanFast() {
    fan.innerHTML = '';
    const W = fan.offsetWidth;
    const rows = Math.ceil(deck.length / PER_ROW);
    const frag = document.createDocumentFragment();

    // Build all rows immediately with back images
    for (let r = 0; r < rows; r++){
      const slice = deck.slice(r * PER_ROW, (r + 1) * PER_ROW);

      // Row container
      const row = document.createElement('div');
      row.className = 'fan-row';
      row.setAttribute('role', 'list');
      frag.appendChild(row);

      // --- Card width (scaled) --------------------------------------
      const MAX_W = 140, MIN_W = 90;
      const cols = Math.min(slice.length, 8);
      const overlapFactor = collapsed ? 1 : 0.6;
      let baseCw = Math.min(MAX_W, Math.max(MIN_W, W / (cols * overlapFactor + 0.25)));
      if (collapsed) baseCw = 130;
      const cw = Math.round(baseCw * cardScale);
      row.style.setProperty('--cw', `${cw}px`);
      row.dataset.cw = cw;

      // --- Place cards ------------------------------------------------
      const geom = rowGeom(slice.length, cw, W);
      slice.forEach((card, i) => {
        const c = document.createElement('button');
        c.type = 'button';
        c.className = 'fan-card';
        c.dataset.id = card.id;
        c.setAttribute('role', 'listitem');
        c.setAttribute('aria-label', card.name || `Card ${card.id}`);
        c.draggable = true;
        c.style.setProperty('--row', r);
        styleCard(c, geom[i], i, slice.length);
        
        // Always show back image initially - no automatic loading
        c.innerHTML = `<img alt="back" src="${cardBackURL}" loading="eager"><span class="num">${card.id}</span>`;

        // No viewport observation - cards stay as back images until clicked

        row.appendChild(c);
      });
    }

    // Commit to DOM and refresh layout/counters
    fan.appendChild(frag);
    tidyRows();
    updateZ();
    showDeckLoaded();
    syncDiscardSize();
    updateDrawLimitState();
  }


  /* =========================== ANIMATIONS ============================ */
  function flyTo(cardEl, destination, html, onDone, scale=1, autoFlip=true){
    const sRect = cardEl.getBoundingClientRect();
    let final = null; let endX, endY;

    if (html){
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      final = tmp.firstElementChild;
      Object.assign(final.style, { visibility:'hidden', position:'absolute', opacity:0 });
      destination.appendChild(final);
      const fRect = final.getBoundingClientRect();
      endX = fRect.left - sRect.left;
      endY = fRect.top  - sRect.top;
    } else {
      const dRect = destination.getBoundingClientRect();
      endX = (dRect.left + dRect.width/2  - sRect.width/2)  - sRect.left;
      endY = (dRect.top  + dRect.height/2 - sRect.height/2) - sRect.top;
    }

    const clone = cardEl.cloneNode(true);
    Object.assign(clone.style, {
      position:'fixed', left:sRect.left+'px', top:sRect.top+'px',
      width:sRect.width+'px', height:sRect.height+'px', margin:0,
      zIndex:9999, pointerEvents:'none', background:'transparent',
      transition:'transform .65s cubic-bezier(.22,1,.36,1), opacity .45s cubic-bezier(.4,.5,.5,1)',
      boxShadow:'0 8px 40px 8px rgba(39,123,250,.09)'
    });
    document.body.appendChild(clone);
    cardEl.style.visibility = 'hidden';

    requestAnimationFrame(()=>{
      clone.style.transform = `translate(${endX}px, ${endY}px) scale(${scale})`;
      clone.style.opacity = .38;
    });

    const onEnd = ()=>{
      clone.remove();
      if (final){
        Object.assign(final.style, { visibility:'', position:'', opacity:'' });
        if (autoFlip){
          setTimeout(()=>{
            final.querySelector('.card-wrapper')?.classList.add('flipped');
          }, FLIP_DELAY);
        }
      }
      cardEl.remove();
      onDone && onDone(final);
    };
    clone.addEventListener('transitionend', onEnd, {once:true});
  }



  function fanOutFlyCards() {
    if (isFoutFlyMode || deck.length === 0) {
      console.log('Cannot fan out: isFoutFlyMode =', isFoutFlyMode, 'deck.length =', deck.length);
      return;
    }
    

    
    const cardsToFan = deck.length; // Use all available cards
    
    if (cardsToFan === 0) return;
    
    console.log('Fanning out', cardsToFan, 'cards');
    
    // Get random cards from the deck
    const shuffledDeck = [...deck];
    shuffleArr(shuffledDeck);
    const selectedCards = shuffledDeck.slice(0, cardsToFan);
    
    // Create a temporary fan container for the selected cards
    const tempFanContainer = document.createElement('div');
    tempFanContainer.className = 'fan-tableau';
    
    // Position at the same height as the deck
    const deckRect = fan.getBoundingClientRect();
    const deckTop = deckRect.top;
    
    tempFanContainer.style.cssText = `
      position: fixed;
      top: ${deckTop}px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      width: 90vw;
      max-width: 1200px;
      pointer-events: none;
    `;
    document.body.appendChild(tempFanContainer);

    // Calculate fan geometry using the existing rowGeom function
    const W = tempFanContainer.offsetWidth;
    const cw = collapsedCW(); // Use the same card width calculation as the main deck
    const geom = rowGeom(selectedCards.length, cw, W);

    // Create fan row
    const row = document.createElement('div');
    row.className = 'fan-row';
    row.style.setProperty('--cw', `${cw}px`);
    tempFanContainer.appendChild(row);

    // Create and position the fanned cards
    selectedCards.forEach((card, i) => {
      const cardEl = fan.querySelector(`.fan-card[data-id='${card.id}']`);
      if (!cardEl) return;

      // Store original position
      const originalPosition = {
        tx: parseFloat(cardEl.style.getPropertyValue('--tx') || '0'),
        ty: parseFloat(cardEl.style.getPropertyValue('--ty') || '0'),
        rot: parseFloat(cardEl.style.getPropertyValue('--rot') || '0'),
        left: parseFloat(cardEl.style.getPropertyValue('--left') || '0')
      };

      // Create a clone for the fan
      const fanCard = cardEl.cloneNode(true);
      
      // Start from the original card position
      const cardRect = cardEl.getBoundingClientRect();
      const containerRect = tempFanContainer.getBoundingClientRect();
      
      // Calculate relative position from original card to fan container
      const startX = cardRect.left - containerRect.left;
      const startY = cardRect.top - containerRect.top;
      
      // Set initial position (same as original card)
      fanCard.style.cssText = `
        position: absolute;
        left: ${startX}px;
        top: ${startY}px;
        width: ${cw}px;
        transform: translate3d(0px, 0px, 0) rotate(0deg);
        transition: all 0.3s cubic-bezier(.25,.8,.35,1), transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;
        pointer-events: auto;
        z-index: 1000;
        box-shadow: 0 2px 8px 1px rgba(60,70,120,.08);
      `;
      row.appendChild(fanCard);
      
      // Animate to final fan position with alternating left/right stagger
      const centerIndex = Math.floor(selectedCards.length / 2);
      let delay;
      
      if (i <= centerIndex) {
        // Left side: start from center and go left
        delay = (centerIndex - i) * 25;
      } else {
        // Right side: start from center and go right
        delay = (i - centerIndex) * 25;
      }
      
      setTimeout(() => {
        fanCard.style.left = `${geom[i].left}px`;
        fanCard.style.top = '0px';
        fanCard.style.transform = `translate3d(${geom[i].tx}px, ${geom[i].ty}px, 0) rotate(${geom[i].rot}deg)`;
      }, delay);

      // Store card info
      foutFlyCards.set(card.id, {
        element: cardEl,
        originalPosition: originalPosition,
        fanElement: fanCard,
        fanContainer: tempFanContainer,
        card: card
      });

      // Hide the original card
      cardEl.style.visibility = 'hidden';

      // Add hover and click handlers to the fan card
      fanCard.addEventListener('mouseenter', () => {
        fanCard.style.filter = 'brightness(1.07) saturate(1.13)';
        fanCard.style.transform = `translate3d(${geom[i].tx}px, ${geom[i].ty - 10}px, 0) rotate(${geom[i].rot}deg) scale(1.04)`;
        fanCard.style.boxShadow = '0 16px 40px 10px rgba(39,123,250,.17)';
      });
      
      fanCard.addEventListener('mouseleave', () => {
        fanCard.style.filter = 'none';
        fanCard.style.transform = `translate3d(${geom[i].tx}px, ${geom[i].ty}px, 0) rotate(${geom[i].rot}deg)`;
        fanCard.style.boxShadow = '0 2px 8px 1px rgba(60,70,120,.08)';
      });
      
            fanCard.addEventListener('click', () => {
        // Check draw limit first
        if (drawLimit > 0 && revealed.length >= drawLimit) {
          return; // Don't allow more cards to be revealed
        }
        
        // Show loading indicator (same as deck cards)
        if (!card.url) {
          // Move this card to highest priority in loading queue
          loadingQueue.unshift({ card, priority: true });
          processLoadingQueue();
          
          // Show loading indicator
          loadingIndicator.classList.add('visible');
          loadingIndicator.querySelector('span').textContent = 'Loading card...';
        }
        
        // Reveal the card
        toReveal(card, fanCard, true);
        
        // Remove the card from the fan
        fanCard.remove();
        
        // Remove from foutFlyCards tracking
        foutFlyCards.delete(card.id);
        
        // If no more cards in fan, reset the mode
        if (foutFlyCards.size === 0) {
          isFoutFlyMode = false;
          foutFlyB.textContent = 'FOutFly';
          foutFlyB.disabled = false;
          
          // Remove the fan container
          const fanContainers = document.querySelectorAll('.fan-tableau[style*="position: fixed"]');
          fanContainers.forEach(container => container.remove());
          
          // Show the original card again
          cardEl.style.visibility = 'visible';
          
          // Show discard pile again
          if (pileArea) {
            pileArea.style.opacity = '';
            pileArea.style.pointerEvents = '';
          }
        }
      });
    });
    
    isFoutFlyMode = true;
    foutFlyB.textContent = 'Un-FOutFly';
    foutFlyB.disabled = true;
    

    
    // Hide discard pile during FOutFly
    if (pileArea) {
      pileArea.style.opacity = '0';
      pileArea.style.pointerEvents = 'none';
    }

    // Re-enable button after animation
    setTimeout(() => {
      foutFlyB.disabled = false;
    }, 200);
  }
  
  function unfoutFlyCards() {
    if (!isFoutFlyMode || foutFlyCards.size === 0) return;
    
    foutFlyB.disabled = true;
    
    // Get the original card positions for smooth return animation
    const originalPositions = new Map();
    foutFlyCards.forEach((foutFlyCard, cardId) => {
      const { element: cardEl } = foutFlyCard;
      const cardRect = cardEl.getBoundingClientRect();
      const containerRect = document.querySelector('.fan-tableau[style*="position: fixed"]')?.getBoundingClientRect();
      
      if (containerRect) {
        originalPositions.set(cardId, {
          x: cardRect.left - containerRect.left,
          y: cardRect.top - containerRect.top
        });
      }
    });
    
    // Animate cards back to their original positions
    foutFlyCards.forEach((foutFlyCard, cardId) => {
      const { element: cardEl, originalPosition, fanElement, fanContainer, card } = foutFlyCard;
      const originalPos = originalPositions.get(cardId);
      
      if (fanElement && originalPos) {
        // Animate back to original position
        fanElement.style.transition = 'all 0.3s cubic-bezier(.25,.8,.35,1)';
        fanElement.style.left = `${originalPos.x}px`;
        fanElement.style.top = `${originalPos.y}px`;
        fanElement.style.transform = 'translate3d(0px, 0px, 0) rotate(0deg)';
        
        // Remove the fan element after animation
        setTimeout(() => {
          if (fanElement && fanElement.parentNode) {
            fanElement.remove();
          }
        }, 300);
      } else {
        // Fallback: remove immediately
        if (fanElement) {
          fanElement.remove();
        }
      }
      
      // Show the original card again
      cardEl.style.visibility = 'visible';
    });
    
    // Remove the fan container after animations complete
    setTimeout(() => {
      const fanContainers = document.querySelectorAll('.fan-tableau[style*="position: fixed"]');
      fanContainers.forEach(container => container.remove());
      
          // Clear state
    foutFlyCards.clear();
    isFoutFlyMode = false;
    foutFlyB.textContent = 'FOutFly';
    foutFlyB.disabled = false;
    

    
    // Show discard pile again
    if (pileArea) {
      pileArea.style.opacity = '';
      pileArea.style.pointerEvents = '';
    }
      
      // Rebuild the fan to ensure cards are back in the deck
      if (collapsed) {
        buildFanFast();
      } else {
        buildFan();
      }
      updateCounts();
    }, 400); // Wait for animations to complete
  }

  /* ========================== ACTIONS ================================ */
  async function toReveal(card, el, fly=true){

    // Build placeholder (front uses back image for seamless spin-in)
    const placeholderHTML = flipHTML({ ...card, url: cardBackURL });

    // Arm flip only after *priority* front decode
    const armFlip = wrapper => {
      // If card already has URL, use it immediately
      if (card.url) {
        const frontImg = wrapper.querySelector('.card-front img');
        frontImg.src = card.url;
        requestAnimationFrame(()=>{
          wrapper.querySelector('.card-wrapper')?.classList.add('flipped');
        });
        loadingIndicator.classList.remove('visible');
        return;
      }
      
      // Otherwise, wait for it to load with priority
      ensureFront(card, {priority:true}).then(url=>{
        if (!url) {
          loadingIndicator.classList.remove('visible');
          return;
        }
        const frontImg = wrapper.querySelector('.card-front img');
        frontImg.src = url;
        requestAnimationFrame(()=>{
          wrapper.querySelector('.card-wrapper')?.classList.add('flipped');
        });
        loadingIndicator.classList.remove('visible');
      });
    };

    const finalize = (wrapper) => {
      deck = deck.filter(c => c.id !== card.id);
      revealed.push(card);
      updateCounts();
      if (wrapper) armFlip(wrapper);
    };

    if (fly){
      flyTo(el, selected, placeholderHTML, finalize, 1.07, /*autoFlip*/ false);
    } else {
      el.remove();
      updateCounts();
      selected.insertAdjacentHTML('beforeend', placeholderHTML);
      finalize(selected.lastElementChild);
    }
  }

  function toDiscard(card, el, fly=true){
    if (!allowDiscard) return;
    const finalize = ()=>{
      deck = deck.filter(c => c.id !== card.id);
      discard.push(card);
      updateCounts();
    };
    if (fly){
      flyTo(el, pileStack, '', finalize, 0.93);
    } else {
      el.remove(); finalize();
    }
  }

  function restorePile(){
    if (!allowDiscard || !discard.length) return;
    deck.push(discard.pop());
    buildFan(); updateCounts();
  }

  /* ========================== MODAL FUNCTIONS ========================== */
  function openModal(index) {
    currentModalIndex = index;
    showCardInModal(currentModalIndex);

    // Always display the modal
    modal.style.display = 'block';

    // Always display the nav (so "Show Details" is available).
    modalNav.style.display = 'flex';

    // Still disable prev/next if needed
    prevBtn.disabled = (index === 0);
    nextBtn.disabled = (index === revealed.length - 1);
  }

  function showCardInModal(idx) {
    const cd = revealed[idx];
    if (!cd) return;

    // If we haven't stored a "currentOrientation" yet, default it to the server's orientation
    if (typeof cd.currentOrientation === 'undefined') {
      cd.currentOrientation = cd.orientation || 'upright';
    }

    // 1) If we have an image
    if (cd.url) {
      modalImg.src = cd.url;
      // Always apply transform based on the *current* orientation
      modalImg.style.transform =
        (cd.currentOrientation === 'reversed')
          ? 'rotate(180deg)'
          : 'rotate(0)';
      modalImg.style.display = 'block';
    } else {
      // No image
      modalImg.src = '';
      modalImg.style.display = 'none';
    }

    // If details are NOT visible, let's ensure the large class is added
    const modalImageDiv = document.querySelector('.modal-image');
    if (!detailsVisible) {
      modalImageDiv.classList.add('modal-image-large');
    } else {
      modalImageDiv.classList.remove('modal-image-large');
    }

    // 2) Set the caption
    const mainWord = cd.name || `Card #${cd.id}`;
    modalCaption.textContent = mainWord;

    // 3) Clear out & rebuild the right‐side details
    if (detailsSide) {
      detailsSide.innerHTML = '';
      // For now, just show basic card info
      detailsSide.innerHTML = `
        <h3>${mainWord}</h3>
        <p><strong>Card ID:</strong> ${cd.id}</p>
        <p><strong>Key:</strong> ${cd.key}</p>
        <p><strong>URL:</strong> ${cd.url || 'Not loaded'}</p>
      `;

      if (detailsVisible) {
        detailsSide.style.display = 'block';
        modalContentWrapper.classList.add('show-details');
        if (toggleDetailsBtn) toggleDetailsBtn.textContent = 'Hide Details';
      } else {
        detailsSide.style.display = 'none';
        modalContentWrapper.classList.remove('show-details');
        if (toggleDetailsBtn) toggleDetailsBtn.textContent = 'Show Details';
      }
    }

    // 4) Prev/Next button states
    prevBtn.disabled = (idx === 0);
    nextBtn.disabled = (idx === revealed.length - 1);
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  /* ========================== RENDERING ============================== */
  function buildFan(){
    // Clear and prep a fragment to minimize reflows
    fan.innerHTML = '';
    const W = fan.offsetWidth;
    const rows = Math.ceil(deck.length / PER_ROW);
    const frag = document.createDocumentFragment();

    // Build all rows immediately but with placeholder cards
    for (let r = 0; r < rows; r++){
      const slice = deck.slice(r * PER_ROW, (r + 1) * PER_ROW);

      // Row container
      const row = document.createElement('div');
      row.className = 'fan-row';
      row.setAttribute('role', 'list');
      frag.appendChild(row);

      // --- Card width (scaled) --------------------------------------
      const MAX_W = 140, MIN_W = 90;
      const cols = Math.min(slice.length, 8);
      const overlapFactor = collapsed ? 1 : 0.6;
      let baseCw = Math.min(MAX_W, Math.max(MIN_W, W / (cols * overlapFactor + 0.25)));
      if (collapsed) baseCw = 130;
      const cw = Math.round(baseCw * cardScale);
      row.style.setProperty('--cw', `${cw}px`);
      row.dataset.cw = cw;

      // --- Place cards ------------------------------------------------
      const geom = rowGeom(slice.length, cw, W);
      slice.forEach((card, i) => {
        const c = document.createElement('button');
        c.type = 'button';
        c.className = 'fan-card';
        c.dataset.id = card.id;
        c.setAttribute('role','listitem');
        c.setAttribute('aria-label', card.name || `Card ${card.id}`);
        c.draggable = true;
        c.style.setProperty('--row', r);
        styleCard(c, geom[i], i, slice.length);
        
        // Use card front image if available, otherwise back image
        const imgSrc = card.url || cardBackURL;
        c.innerHTML = `<img alt="${card.url ? 'front' : 'back'}" src="${imgSrc}" loading="eager"><span class="num">${card.id}</span>`;

        // Queue loading for cards without front images
        if (!card.url) {
          queueCardLoad(card, r === 0 && i < 3); // Priority for first 3 cards of first row
        }

        // Optional viewport warm-up
        if (typeof io !== 'undefined' && io) io.observe(c);

        row.appendChild(c);
      });
    }

    // Commit to DOM and refresh layout/counters
    fan.appendChild(frag);
    tidyRows();
    updateZ();
    updateCounts();
    syncDiscardSize();
    updateDrawLimitState();

    // Start progressive loading immediately
    if (deck.length > 0) {
      // Load first few cards with high priority
      const firstCards = deck.slice(0, Math.min(5, deck.length));
      firstCards.forEach((card, index) => {
        if (!card.url) {
          setTimeout(() => queueCardLoad(card, true), index * 50); // Stagger first cards
        }
      });
    }
  }




  function syncDiscardSize(){
  // Use the same size as collapsed deck (130px base)
  const base = 130;
  pileStack.style.width = (base * cardScale) + 'px';
}



const cardSize = document.getElementById('cardSize');
cardSize.onchange = () => {
  cardScale = parseFloat(cardSize.value) || 1;

  // Update shared sizes first
  applyCollapsedSize();

  if (collapsed) {
    recalc('collapsed');      // recompute geometry using new --cw with explicit collapsed mode
  } else {
    buildFan();               // fan view uses dynamic width; rebuild with proper images
  }

  syncDiscardSize();          // keep discard looking right in both modes
};

const drawLimitSelect = document.getElementById('drawLimit');
drawLimitSelect.onchange = () => {
  drawLimit = parseInt(drawLimitSelect.value) || 0;
  updateDrawLimitState();
};



  const recalc = (mode /* 'collapsed' | 'fan' | undefined */, additionalOffset = 0) => {
    const rows = document.querySelectorAll('.fan-row');

    rows.forEach(row => {
      const cards = [...row.children];
      if (!cards.length) return;

      const MAX_W = 140, MIN_W = 90;
      const cols = Math.min(cards.length, 8);

      const useCollapsed = mode ? (mode === 'collapsed') : collapsed;
      const overlapFactor = useCollapsed ? 1 : 0.6;

      // Per-card width for this row
      const cw = useCollapsed
        ? collapsedCW()
        : Math.round(Math.min(MAX_W, Math.max(MIN_W,
            fan.offsetWidth / (cols * overlapFactor + 0.25))) * cardScale);

      // CRITICAL: in collapsed mode, treat the row width as cw so spread == 0.
      const W = useCollapsed ? cw : fan.offsetWidth;

      row.style.setProperty('--cw', `${cw}px`);
      row.dataset.cw = cw;

              const geom = rowGeom(cards.length, cw, W);
      cards.forEach((c, i) => styleCard(c, geom[i], i, cards.length, additionalOffset));
    });

    tidyRows();
    updateZ();
    syncDiscardSize();
  };

  function setCollapsed(shouldCollapse){
    const collapseMs = FAN_MS_COLLAPSE();
    const expandMs   = FAN_MS_EXPAND();
    toggling = true;

    if (shouldCollapse && !collapsed){
      // PHASE A — animate collapse in wide geometry
      fan.classList.add('is-collapsing');

      // kick the transform-only collapse
      requestAnimationFrame(() => {
        fan.classList.add('is-collapsed');
        collapsed = true;
        collapseB.textContent = 'Fan Out';
      });

      // PHASE B — after motion ends, snap to narrow column with transitions OFF
      setTimeout(() => {
        fan.classList.add('is-freeze');              // disable transitions for one frame
        deckWrap && deckWrap.classList.add('collapsed-mode');
        applyCollapsedSize();                        // set --cw for the column
        recalc('collapsed');                         // recompute (spread==0, stackX→0)
        tidyRows();

        // unfreeze next frame and clean up flags
        requestAnimationFrame(() => {
          fan.classList.remove('is-freeze');
          fan.classList.remove('is-collapsing');
          toggling = false;
        });
      }, collapseMs + 10);

    } else if (!shouldCollapse && collapsed){
      // PREP — go back to wide layout and compute fan geometry with transitions OFF
      fan.classList.add('is-freeze');
      deckWrap && deckWrap.classList.remove('collapsed-mode');
      applyCollapsedSize();
      recalc('fan');                                  // set new fan left/tx/ty/rot
      tidyRows();

      // PHASE — unstack with a single smooth fan‑out
      requestAnimationFrame(() => {
        fan.classList.remove('is-freeze');
        fan.classList.add('is-expanding');
        fan.classList.remove('is-collapsed');         // triggers the fan-out animation
        collapsed = false;
        collapseB.textContent = 'Collapse';
      });

      setTimeout(() => {
        fan.classList.remove('is-expanding');
        toggling = false;
      }, expandMs + 10);

    } else {
      toggling = false; // no-op
    }
  }

  const shuffleArr = a => { 
    for(let i=a.length-1;i>0;i--){ 
      const j=(Math.random()* (i+1))|0; 
      [a[i],a[j]]=[a[j],a[i]]; 
    }
  };
  const riffle = () => {
    fan.classList.add('is-shuffling');
    setTimeout(()=>fan.classList.remove('is-shuffling'), RIFFLE_MS_VAR());
  };

  /* ========================== DRAG & DROP ============================ */
  function makeDragGhost(w, h, src){
    const g = new Image(); g.src = src;
    Object.assign(g.style, {
      width: w+'px', height: h+'px', borderRadius:'16px',
      position:'absolute', top:'-999px', left:'-999px'
    });
    document.body.appendChild(g);
    return g;
  }

  // From pile back to deck
  pileStack.addEventListener('dragstart', e=>{
    if (!allowDiscard || !discard.length) return;
    e.dataTransfer.setData('text/x-pile', 'top');
    const g = makeDragGhost(pileStack.offsetWidth, pileStack.offsetHeight, cardBackURL);
    e.dataTransfer.setDragImage(g, g.offsetWidth/2, g.offsetHeight/2);
    setTimeout(()=>g.remove(), 0);
  });

  let deckHover = 0;
  fan.addEventListener('dragenter', e=>{
    if (e.dataTransfer.types.includes('text/x-pile') && allowDiscard){
      deckHover++; fan.classList.add('deck-hover');
    }
  });
  fan.addEventListener('dragleave', e=>{
    if (e.dataTransfer.types.includes('text/x-pile') && allowDiscard){
      deckHover = Math.max(0, --deckHover);
      if (!deckHover) fan.classList.remove('deck-hover');
    }
  });
  fan.addEventListener('dragover', e=>{
    if (e.dataTransfer.types.includes('text/x-pile') && allowDiscard) e.preventDefault();
  });
  fan.addEventListener('drop', e=>{
    if (e.dataTransfer.types.includes('text/x-pile') && allowDiscard){
      e.preventDefault(); deckHover = 0; fan.classList.remove('deck-hover');
      restorePile();
    }
  });

  // Pile accepts card discards
  ['dragenter','dragover'].forEach(evt=>pileArea.addEventListener(evt, e=>{
    if (!allowDiscard) return;
    e.preventDefault(); pileArea.classList.add('hover');
  }));
  ['dragleave','drop'].forEach(evt=>pileArea.addEventListener(evt, ()=>{
    pileArea.classList.remove('hover');
  }));
  pileArea.addEventListener('drop', e=>{
    if (!allowDiscard) return;
    e.preventDefault();
    const id = +e.dataTransfer.getData('text/plain');
    const el = fan.querySelector(`.fan-card[data-id='${id}']`);
    const card = deck.find(c=>c.id === id);
    if (card && el) toDiscard(card, el, false);
  });

  // Reveal strip accepts card drops
  ['dragenter','dragover'].forEach(evt=>selected.addEventListener(evt, e=>{
    if (e.dataTransfer.types.includes('text/x-pile')) return; // ignore pile
    e.preventDefault(); selected.classList.add('drop-hover');
  }));
  ['dragleave','drop'].forEach(evt=>selected.addEventListener(evt, ()=>{
    selected.classList.remove('drop-hover');
  }));
  selected.addEventListener('drop', e=>{
    if (e.dataTransfer.types.includes('text/x-pile')) return;
    e.preventDefault();
    const id = +e.dataTransfer.getData('text/plain');
    const el = fan.querySelector(`.fan-card[data-id='${id}']`);
    const card = deck.find(c=>c.id === id);
    if (card && el) toReveal(card, el, false);
  });

  /* ======================== EVENT DELEGATION ========================= */
  // Click → reveal, Right-click → discard, Drag ghost for cards
  fan.addEventListener('click', e=>{
    const el = e.target.closest('.fan-card');
    if (!el) return;
    const id = +el.dataset.id;
    const card = deck.find(c=>c.id === id);
    if (card) {
      // Check draw limit first before doing any loading
      if (drawLimit > 0 && revealed.length >= drawLimit) {
        // Show visual feedback and return early
        el.classList.add('limit-feedback');
        setTimeout(() => {
          el.classList.remove('limit-feedback');
        }, 150);
        return;
      }

      // If card doesn't have front image loaded, prioritize it
      if (!card.url) {
        // Move this card to highest priority in loading queue
        loadingQueue.unshift({ card, priority: true });
        processLoadingQueue();
        
        // Show loading indicator
        loadingIndicator.classList.add('visible');
        loadingIndicator.querySelector('span').textContent = 'Loading card...';
      }
      toReveal(card, el, true);
    }
  });

  fan.addEventListener('mousedown', e=>{
    if (e.button !== 2) return;
    const el = e.target.closest('.fan-card');
    if (!el || !allowDiscard) return;
    e.preventDefault(); e.stopPropagation();
    const id = +el.dataset.id;
    const card = deck.find(c=>c.id === id);
    if (card) toDiscard(card, el, true);
  });

  fan.addEventListener('contextmenu', e=>{
    if (e.target.closest('.fan-card')) e.preventDefault();
  });

  fan.addEventListener('dragstart', e=>{
    const el = e.target.closest('.fan-card');
    if (!el) return;
    const id = +el.dataset.id;
    const card = deck.find(c=>c.id === id);
    if (!card) return;

    e.dataTransfer.setData('text/plain', id);
    const g = makeDragGhost(el.offsetWidth, el.offsetHeight, cardBackURL);
    e.dataTransfer.setDragImage(g, g.offsetWidth/2, g.offsetHeight/2);
    el.style.opacity = '0';
    el._ghost = g;
  });

  fan.addEventListener('dragend', e=>{
    const el = e.target.closest('.fan-card');
    if (!el) return;
    if (el.isConnected) el.style.opacity = '1';
    el._ghost?.remove(); el._ghost = null;
  });

  // Hover lift only when not collapsed (delegated)
  fan.addEventListener('mouseenter', e=>{
    const el = e.target.closest('.fan-card');
    if (el && !collapsed) el.classList.add('is-lifted');
  }, true);
  fan.addEventListener('mouseleave', e=>{
    const el = e.target.closest('.fan-card');
    if (el) el.classList.remove('is-lifted');
  }, true);
  fan.addEventListener('focusin', e=>{
    const el = e.target.closest('.fan-card');
    if (el && !collapsed) el.classList.add('is-lifted');
  });
  fan.addEventListener('focusout', e=>{
    const el = e.target.closest('.fan-card');
    if (el) el.classList.remove('is-lifted');
  });

  /* =========================== CONTROLS ============================== */
  const disableBtns = x => [collapseB, shuffleB, resetB, foutFlyB].forEach(b=>b.disabled = x);

  collapseB.onclick = () => {
    disableBtns(true);
    const goingToCollapse = !collapsed;
    setCollapsed(goingToCollapse);
    const ms = goingToCollapse ? FAN_MS_COLLAPSE() : FAN_MS_EXPAND();
    setTimeout(() => disableBtns(false), ms + 100);
  };

    foutFlyB.onclick = () => {
    if (isFoutFlyMode) {
      unfoutFlyCards();
    } else {
      fanOutFlyCards();
    }
  };

  // Enhanced shuffle function with messages and deck shake
  function shuffleDeck(onComplete) {
    // Show shuffle message
    shuffleMsg.classList.add('active');
    shuffleText.textContent = "Shuffling Deck...";
    
    // Add deck shake animation
    fan.classList.add('deck-shake');
    
    // Cycle through shuffle messages
    const messages = ["Shuffling Deck...", "Cutting Deck...", "Mixing Cards..."];
    let msgIndex = 0;
    const textInterval = setInterval(() => {
      msgIndex = (msgIndex + 1) % messages.length;
      shuffleText.textContent = messages[msgIndex];
    }, 600);
    
    // Shuffle the deck
    shuffleArr(deck);
    
    setTimeout(() => {
      clearInterval(textInterval);
      fan.classList.remove('deck-shake');
      shuffleText.textContent = "Shuffling Complete";
      
      // Rebuild the fan immediately
      buildFanFast();
      
      // Hide message quickly
      setTimeout(() => {
        shuffleMsg.classList.remove('active');
        shuffleText.textContent = '';
      }, 500);
      
      if (typeof onComplete === 'function') {
        onComplete();
      }
    }, 1500);
  }

  shuffleB.onclick = () => {
    disableBtns(true);

    // If FOutFly is active, handle it specially
    if (isFoutFlyMode) {
      // Store the current FOutFly count (all cards)
      const currentFoutFlyCount = deck.length;
      
      // First, un-FOutFly
      unfoutFlyCards();
      
      // Wait for un-FOutFly to complete, then shuffle and re-FOutFly
      setTimeout(() => {
        const wasCollapsed = collapsed;
        const COLLAPSE_MS = FAN_MS_COLLAPSE();
        const EXPAND_MS = FAN_MS_EXPAND();

        if (!wasCollapsed) {
          // Starting from fanned mode - add shuffling class to hide discard pile
          isShuffling = true;
          deckWrap.classList.add('shuffling');
          setCollapsed(true);
          
          setTimeout(() => {
            shuffleDeck(() => {
              setTimeout(() => {
                setCollapsed(false);
                // Remove shuffling class after animation completes
                isShuffling = false;
                deckWrap.classList.remove('shuffling');

                // Re-FOutFly with the same count
                setTimeout(() => {
                  fanOutFlyCards();
                  setTimeout(() => disableBtns(false), 200);
                }, EXPAND_MS + 20);
              }, COLLAPSE_MS);
            });
          }, COLLAPSE_MS + 20);
        } else {
          // Starting from collapsed mode - discard pile can stay visible
          shuffleDeck(() => {
            // Re-FOutFly with the same count
            setTimeout(() => {
              fanOutFlyCards();
              setTimeout(() => disableBtns(false), 200);
            }, 100);
          });
        }
      }, 400); // Wait for un-FOutFly animation to complete
      
      return;
    }

    // Regular shuffle (when FOutFly is not active)
    const wasCollapsed = collapsed;
    const COLLAPSE_MS = FAN_MS_COLLAPSE();
    const EXPAND_MS = FAN_MS_EXPAND();

    if (!wasCollapsed) {
      // Starting from fanned mode - add shuffling class to hide discard pile
      isShuffling = true;
      deckWrap.classList.add('shuffling');
      setCollapsed(true);
      
      setTimeout(() => {
        shuffleDeck(() => {
          setTimeout(() => {
            setCollapsed(false);
            // Remove shuffling class after animation completes
            isShuffling = false;
            deckWrap.classList.remove('shuffling');
            setTimeout(() => disableBtns(false), EXPAND_MS + 20);
          }, COLLAPSE_MS);
        });
      }, COLLAPSE_MS + 20);
    } else {
      // Starting from collapsed mode - discard pile can stay visible
      shuffleDeck(() => {
        setTimeout(() => disableBtns(false), 100);
      });
    }
  };

  enableDiscard.onchange = () => {
    allowDiscard = enableDiscard.checked;
    pileArea.style.display = allowDiscard ? 'flex' : 'none';
    updateCounts();
  };

  collapseMode.onchange = () => {
    const m = collapseMode.value;
    if (m === 'both'){
      allowCollapse = true; collapseB.style.display = '';
      if (deckWrap) deckWrap.style.gap = '48px';
    } else {
      allowCollapse = false; collapseB.style.display = 'none';
      if (deckWrap) deckWrap.style.gap = (m === 'collapsed' ? '16px' : '48px');
    }
    if (m === 'collapsed') {
      setCollapsed(true);
    }
    if (m === 'foutfly') {
      setCollapsed(false); // First fan out the deck
      // Then trigger FOutFly after a short delay to ensure fan is ready
      setTimeout(() => {
        if (!isFoutFlyMode) {
          fanOutFlyCards();
        }
      }, 100);
    }
  };

  /* ============================== INIT =============================== */
  async function loadDeckMeta(){
    const tag = $('deck-loader');
    const key = (tag.getAttribute('data-deck-key') || '').trim();
    PUBLIC_ID = (tag.getAttribute('data-public-id') || '').trim();

    // 1) GET deck meta
    const url = `${API_DECK}?key=${encodeURIComponent(key)}${PUBLIC_ID ? `&public_id=${encodeURIComponent(PUBLIC_ID)}` : ''}`;
    const meta = await fetchWithRetry(url).then(r=>r.json());

    // 2) resolve back image
    const body = PUBLIC_ID ? {filenames:[meta.cardBack], public_id:PUBLIC_ID} : {filenames:[meta.cardBack]};
    const cb = await fetchWithRetry(API_URLS, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body)
    }).then(r=>r.json());
    cardBackURL = (cb.images || []).find(i=>i.key === meta.cardBack)?.url || '';
    pileStack.style.backgroundImage = cardBackURL ? `url('${cardBackURL}')` : '';

    // 3) set CSS aspect ratio
    await new Promise(res=>{
      const im = new Image();
      im.onload = ()=>{
        document.documentElement.style.setProperty('--card-aspect', im.naturalWidth / im.naturalHeight);
        res();
      };
      im.src = cardBackURL;
    });

    // 4) create deck skeleton
    deck = meta.cards.map((c,i)=>({
      id: i+1,
      key: c.frontImageS3Key,
      url: null,
      name: c.title || c.name || ''
    }));
  }

  function softReset(){
    // First, make all original deck cards visible again
    if (isFoutFlyMode && foutFlyCards.size > 0) {
      foutFlyCards.forEach((foutFlyCard, cardId) => {
        const { element: cardEl } = foutFlyCard;
        // Make sure the original card is visible again
        if (cardEl) {
          cardEl.style.visibility = 'visible';
        }
      });
      
      // Remove any FOutFly fan containers
      const fanContainers = document.querySelectorAll('.fan-tableau[style*="position: fixed"]');
      fanContainers.forEach(container => container.remove());
      
      // Show discard pile again
      if (pileArea) {
        pileArea.style.opacity = '';
        pileArea.style.pointerEvents = '';
      }
      
      // Clear FOutFly state
      foutFlyCards.clear();
      isFoutFlyMode = false;
      foutFlyB.textContent = 'FOutFly';
      foutFlyB.disabled = false;
    }
    
    // Reset all card arrays and UI
    // Only add discard and revealed cards back to deck (FOutFly cards are already in deck)
    deck.push(...discard, ...revealed);
    discard.length = 0; 
    revealed.length = 0;
    selected.innerHTML = '';
    
    // Reset to collapsed state (like init)
    collapsed = true;
    fan.classList.add('is-collapsed');
    if (deckWrap) deckWrap.classList.add('collapsed-mode');
    collapseB.textContent = 'Fan Out';
    
    // Reset collapse mode to 'both'
    if (collapseMode) {
      collapseMode.value = 'both';
      allowCollapse = true;
      collapseB.style.display = '';
      if (deckWrap) deckWrap.style.gap = '48px';
    }
    
    // Shuffle and rebuild
    shuffleArr(deck);
    buildFanFast(); 
    updateCounts();
    recalc();
    
    // Sync discard size
    syncDiscardSize();
  }

  resetB.onclick = softReset;

  async function init(){
    discard = []; revealed = [];
    selected.innerHTML = '';
    collapsed = true; 
    fan.classList.add('is-collapsed');
    if (deckWrap) deckWrap.classList.add('collapsed-mode');
    collapseB.textContent = 'Fan Out';
    
    // Reset fan out fly state
    foutFlyCards.clear();
    isFoutFlyMode = false;
    foutFlyB.textContent = 'FOutFly';
    foutFlyB.disabled = false;

    // Ensure loading state is visible
    if (deckLoading) deckLoading.classList.remove('hidden');
    if (deckCount) deckCount.style.display = 'none';
    if (deckInfo) deckInfo.style.display = 'none';
    
    // Hide discard pile until deck loads
    if (pileArea) {
      pileArea.style.opacity = '0';
      pileArea.style.pointerEvents = 'none';
    }

    await loadDeckMeta();
    shuffleArr(deck);
    
    // Use fast fan building - show all cards immediately with back images
    buildFanFast();

    // Start background loading immediately
    idleWarm();

    collapseMode.dispatchEvent(new Event('change'));
    syncDiscardSize();
    
    // Show discard pile after deck is loaded
    if (pileArea) {
      pileArea.style.opacity = '';
      pileArea.style.pointerEvents = '';
    }
  }

  // Keyboard goodies
  document.addEventListener('keydown', (e)=>{
    // Modal keyboard controls
    if (modal.style.display === 'block') {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeModal();
        return;
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (currentModalIndex < revealed.length - 1) {
          currentModalIndex++;
          showCardInModal(currentModalIndex);
        }
        return;
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (currentModalIndex > 0) {
          currentModalIndex--;
          showCardInModal(currentModalIndex);
        }
        return;
      }
    }

    const active = document.activeElement;
    const isCard = active && active.classList?.contains('fan-card');
    if (e.key === 'c' || e.key === 'C') { collapseB.click(); }
    if (e.key === 's' || e.key === 'S') { shuffleB.click(); }
    if (e.key === 'r' || e.key === 'R') { resetB.click(); }
    if (e.key === 'o' || e.key === 'O') { foutFlyB.click(); }

    if (!isCard) return;

    const row = active.closest('.fan-row');
    const cards = [...row.querySelectorAll('.fan-card')].sort((a,b)=>a.offsetLeft-b.offsetLeft);
    const idx = cards.indexOf(active);
    if (e.key === 'ArrowRight' && idx < cards.length - 1){ e.preventDefault(); cards[idx+1].focus(); }
    if (e.key === 'ArrowLeft'  && idx > 0){ e.preventDefault(); cards[idx-1].focus(); }
    if (e.key === 'Enter'){ e.preventDefault(); const id=+active.dataset.id; const card=deck.find(c=>c.id===id); if (card) toReveal(card, active, true); }
    if ((e.key === 'Delete' || e.key === 'Backspace') && allowDiscard){
      e.preventDefault(); const id=+active.dataset.id; const card=deck.find(c=>c.id===id); if (card) toDiscard(card, active, true);
    }
  });

  // don't rebuild the fan while toggling
  window.addEventListener('resize', rafThrottle(() => {
    if (!collapsed && !toggling) buildFanFast();
  }));

  // Modal event listeners
  closeBtn.addEventListener('click', closeModal);
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });

  nextBtn.addEventListener('click', () => {
    if (currentModalIndex < revealed.length - 1) {
      currentModalIndex++;
      showCardInModal(currentModalIndex);
    }
  });

  prevBtn.addEventListener('click', () => {
    if (currentModalIndex > 0) {
      currentModalIndex--;
      showCardInModal(currentModalIndex);
    }
  });

  toggleDetailsBtn.addEventListener('click', () => {
    if (!detailsVisible) {
      // We are about to show details
      detailsSide.style.display = 'block';
      modalContentWrapper.classList.add('show-details'); 
      toggleDetailsBtn.textContent = 'Hide Details';
      detailsVisible = true;

      // Remove the "large" class since details are visible
      const modalImageDiv = document.querySelector('.modal-image');
      modalImageDiv.classList.remove('modal-image-large');

      closeBtn.style.color = '#000';
    } else {
      // We are about to hide details
      detailsSide.style.display = 'none';
      modalContentWrapper.classList.remove('show-details');
      toggleDetailsBtn.textContent = 'Show Details';
      detailsVisible = false;

      // Add the "large" class because the details are now hidden
      const modalImageDiv = document.querySelector('.modal-image');
      modalImageDiv.classList.add('modal-image-large');

      closeBtn.style.color = '#fff';
    }
  });

  // Add click handlers to revealed cards
  selected.addEventListener('click', (e) => {
    const cardElement = e.target.closest('.selected-card');
    if (cardElement) {
      const cardId = parseInt(cardElement.dataset.cardId);
      const cardIndex = revealed.findIndex(card => card.id === cardId);
      if (cardIndex !== -1) {
        openModal(cardIndex);
      }
    }
  });

  init();
  </script>
</body>
</html>
